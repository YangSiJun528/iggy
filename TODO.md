### 목표
Custom Wireshark Dissector(Lua 기반)를 만들어 iggy 프로토콜의 **바이너리 통신(TCP/QUIC)** 데이터를 분석 가능하게 한다. HTTP(JSON)는 제외한다.

코드는 프로젝트 루트 경로 하위에 protocol-dissector 디렉토리를 만들고, iggy 프로젝트의 하위 프로젝트로 추가하여, 필요한 의존성만 받도록 한다. 
테스트코드를 작성할 때, 바이너리 데이터를 실제 iggy 서버의 로직을 사용하여 변경에 유현하게 대응하기 위함이다. 

***

### 전반적 요구사항

- iggy 프로토콜의 TCP 및 QUIC 통신은 바이너리 형식으로 이루어짐.
- 바이너리 데이터의 형식을 코드를 통해 분석하고, Wireshark에서 사람이 읽기 쉽게 파싱하도록 함.
- 프로토콜 포맷만 준수한다면, 데이터 전송 방식 자체는 제한하지 않음.
- Request와 Response를 각각 별도로 구현해야 함.

***

### 개발 방향

- **언어:** Lua
    - Wireshark에서 Lua 기반 dissector 지원이 풍부하고 문법이 단순함.
- **자동화:** Wireshark의 경량 CLI `tshark`를 호출해 테스트를 자동화.
- **분석 대상 코드:**
    - Request 코드/이름: `core/common/src/types/command/mod.rs`
    - 바이너리 명세 관리: `core/server/src/binary/command.rs`
    - 각 프로토콜 struct는 `BytesSerializable` 트레이트를 구현함.  
      이 구현을 분석하여 실제 바이트 구조를 파악.

***

### 공통 데이터 타입 처리

- 공통 데이터 타입에 대한 개별 파서를 만들어 재사용.  
  Wireshark에서도 해당 타입을 식별 가능해야 함.
- 코드로부터 확인할 주요 공통 타입 예시:  
  Consumer, Identifier, PolledMessages, Message, ConsumerOffsetInfo  
  (단, 오래된 문서 기준이므로 실제 구현을 코드로 검증해야 함.)
- 공통 처리 기준:  
  `BytesSerializable`을 구현하고, 여러 프로토콜에서 재사용되는 경우 공통 타입으로 간주한다.

***

### 프로토콜 스키마

#### Request

| 필드 | 크기 | 설명 |
|------|------|------|
| length | 4 bytes (u32) | 전체 길이 = code(4) + payload(N) |
| code | 4 bytes (u32) | 요청 코드 |
| payload | N bytes | 실제 데이터 |

**예시:** payload가 100 bytes라면  
length는 104 (code + payload)  
총 메시지 크기는 108 bytes (length + code + payload)

#### Response

| 필드 | 크기 | 설명 |
|------|------|------|
| status | 4 bytes (u32) | 상태 코드 (0: 성공, 그 외: 오류) |
| length | 4 bytes (u32) | 전체 길이 = status(4) + payload(N) |
| payload | N bytes | 응답 데이터 (성공 시에만 존재) |

**에러 처리 규칙:**
- `status`가 에러일 경우: length는 0, payload는 비어 있음.
- 존재하지 않는 리소스 요청 시: status 0이지만 payload 비어 있음.

***

### 에러 코드

- 중앙 관리 위치: `core/common/src/error/iggy_error.rs`
- HTTP 전송용 변환: `core/server/src/http/error.rs`  
  (Dissector에는 직접 필요 없지만 문맥 참고용)

----

### 초기 구현 시 주의사항

- **TCP 세그먼트 재조립은 당장 고려하지 않음.**
    - 단순 데모용 구현 후 피드백을 받는 단계.
    - 나중에 추가 시 Length 필드 기반으로 전체 메시지 크기를 계산하고,  
      Wireshark의 `desegment_len` 값을 통해 구현.
- **필드 및 관련 로직의 변경 용이성 확보.**
    - 구조별, 역할별 Lua 스크립트 분리 및 모듈화.
        - 요청 code 별로 payload 처리하는 함수 포인터, 필드 정의, 이름 등을 묶어서 관리해야 한다.
        - lua의 테이블을 사용하여 묶어서 관리한다.

# 이제 해야 할거

1. 코드 더 다듬기 + 내가 이해하고 수정 가능하게 하기
   - 아직 일부 구현은 이해 안되는거 있음. 그런건 더 알아봐야 함.
   - 코드 다듬는 부분은 지금도 충분해보이긴 함. field 부분을 어떻게 할지는 좀 고민이긴 한데, 가독성을 생각하면 지금도 충분히 괜찮지 않나? 이런 선언 부분을 아예 함수로 빼는것도 가능하긴 할건데, 그렇다고 가독성이 크게 좋아지는 것도 아닌...
2. TCP 세그먼트 분리 기능 처리하기. 1번 코드 이해하고 나서 몇 줄 추가되는거고, 분석 로직은 안바뀔꺼라 어렵진 않을 듯?
3. 테스트코드 수정하가, 더 보기 좋게하고, 인스턴스 하나 만들어서 각 테스트에서 싱글톤으로 재사용하게 하고 싶은데, 가능할지는 모르겠음.
   - 에러 핸들링하는 부분은 직접 만들어야 하긴 함.
4. 일부 프로토콜 한 5개 정도? 만들어서 PR 올리기. 어차피 전체적인 구조에 대한 피드백을 받는거고, 다 구현하던말던구현 방식은 비슷할꺼라 중간단계에서 받는게 맞음

# Lua API 공부하기

https://gist.github.com/YangSiJun528/df80609ad4b4bcf0375fbe5c92ce5388 

여기 실습 파일이랑 

https://www.wireshark.org/docs/wsdg_html_chunked/lua_module_Proto.html

여기선 공식 가이드? 있음

----

- DissectorTable이 아마 등록하거나 등록된 설정 바꾸는거인듯? 휴리스틱을 쓰면 없어도 알아서 등록되는거 같은데
  - Pref - preferences(환경설정) 관련 처리로 포트 번호를 설정할 수 있는듯? 이거 tshark인자로도 설정 가능하면, 그냥 이거 쓰게하면 될 거 같은데?
    - 어차피 서버 주소만 찾으면 되고, 이러면 휴리스틱 굳이 필요없음???은 아닌거 같기도 하고, TCP 위에서 딴걸 보낼 수도 있으니...
      - Pref 사용하면 서버 IP/포트 설정할 수 있음. (클라이언트는 굳이? 포트 식별이 의미가 없어보이기도 하고? IP 등으로 제한할 수 있긴 한데, 그정도까지..?)
      - 이러면 다른 포트로 요청/응답이 전송되면 Heuristic 처리를 건너 뛰므로 더 전체적인 처리가 좀 더 빨라질 수 있음.
        - 그래도 파싱으로 분석해야 하긴 해서, 지금 로직은 유지될 듯 (단, 요청/응답으로 경우의 수를 줄일 수 있긴 함)
        - 일단 Heuristic 지우고, 서버 IP/포트 설정된거 기준으로만 보게 하기.
          - 나중에 시간 되면
            - Heuristic + Heuristic fallback 추가
            - 클라이언트 IP/포트 리스트, Range 기반 처리 가능하게
  - Proto: 새 프로토콜 정의
  - ProtoField: 새 프로토콜 필드 정의. `proto_name.fields = {}`로 등록하는 건 따로.
    - 정의는 스크립트 로딩 떄, 값 할당은 디섹션 로딩(패킷오고 처리해야할 떄마다 실행됨) 때
  - Field는 Wireshark에 등록된(ProtoField로 만든거도 포함) 잡아놓은 필드 이름으로 가져오는거.
    - ProtoField 값 할당이 되어있는 상태에서 호출해야 정상적으로 됨.
    - 근데 보니까, 복잡한 경우에만 쓰고 지금처럼 역직렬화/직렬화 정도에서는 굳이 필요 없는 듯?
    - 일단 이런거 있다는거만 알아두기

대충 시점
```
Wireshark 시작
↓
스크립트 로딩: ProtoField 정의, Field 객체 생성
↓
사용자 패킷 파일 열기
↓
[패킷 1] → 디섹션 로딩 → dns.dissector() 실행
↓
[패킷 2] → 디섹션 로딩 → dns.dissector() 실행  
↓
[패킷 3] → 디섹션 로딩 → dns.dissector() 실행
```

---

일단 새로 프로젝트 파서 단계별로 하는 중인데, lua 먼저 신경써야 할 듯?
rust 테스트코드야 뭐 Claude 보고 알아서 하라그러고
lua를 먼저 괜찮게 만들어야 함. 휴리스틱 빼는게 어려울려나? 일단 최소한으로 ping 구현을 만들고 직접 쳐보면서 이해하는 식으로
파일 분리하면 lua 스크립트 올리고 지우고 하는게 붎편하니까 하나로 관리.


----

생각보다 많이 빡셈...

또 생각해봐야 할게, 요청에 대한 응답을 식별하고 그 payload를 역직렬화 할 수 있는가? (이거 json 형식이라 매핑 필요 없을듯.)

그냥 초안은 코드 복붙해가면서 손으로 짜야할듯? 의도한대로 안나오네
한글 주석 막 쓰고




-----


